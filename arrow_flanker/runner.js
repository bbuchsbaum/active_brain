// Generated by CoffeeScript 1.7.1
(function() {
  var factorSet, fnode, trials, _;

  _ = Psy._;

  this.ArrowFlanker = {};

  this.ArrowFlanker.experiment = {
    Routines: {
      Prelude: {
        Events: {
          1: {
            Markdown: "\n<p>\n<p>\n\n# **<span style=\"color:red\">STOP!</span>**\n\n## **READ** the following Instructions **CAREFULLY**\n\nFlanker Task\n==========================\n\nOn every trial a central arrow will appear surrounded by arrows on either side.\nYour goal is to focus on the central arrow and decide whether it points left or right.\n\n  * If the central arrow points <-- left, press the **left arrow** key.\n\n  * If the central arrow points --> right, press the **right arrow** key.\n\n  * If your response is correct, the screen will briefly turn green.\n\n  * If your response is incorrect, the screen will briefly turn red.\n\n  * make your decision as fast as you can.\n\nPress spacebar to continue\n-------------------------\n",
            Next: {
              SpaceKey: {}
            }
          }
        }
      },
      Block: {
        Start: function() {
          return {
            Text: {
              position: "center",
              origin: "center",
              content: ["Get Ready for Block " + (this.context.get("State.blockNumber")) + "!", "Press the spacebar to start"]
            },
            Next: {
              SpaceKey: {}
            }
          };
        },
        End: function() {
          return {
            Text: {
              position: "center",
              origin: "center",
              content: ["End of Block " + (this.context.get("State.blockNumber")), "Press the spacebar to continue"]
            },
            Next: {
              SpaceKey: {}
            }
          };
        }
      },
      Trial: function() {
        var arrowLen, arrowx, index, x;
        arrowLen = 150;
        arrowx = [this.screen.center.x - 2 * arrowLen - 20, this.screen.center.x - arrowLen - 10, this.screen.center.x, this.screen.center.x + arrowLen + 10, this.screen.center.x + 2 * arrowLen + 20];
        return {
          Background: {
            Blank: {
              fill: "white"
            },
            CanvasBorder: {
              stroke: "black"
            }
          },
          Events: {
            1: {
              FixationCross: {
                fill: "gray"
              },
              Next: {
                Timeout: {
                  duration: 1000
                }
              }
            },
            2: {
              Group: {
                elements: (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (index = _i = 0, _len = arrowx.length; _i < _len; index = ++_i) {
                    x = arrowx[index];
                    _results.push({
                      Arrow: {
                        x: x,
                        y: this.screen.center.y,
                        thickness: 35,
                        arrowSize: 75,
                        origin: "center",
                        fill: "black",
                        length: arrowLen,
                        direction: index === 2 ? this.trial.centerArrow : this.trial.flankerArrow
                      }
                    });
                  }
                  return _results;
                }).call(this)
              },
              Next: {
                KeyPress: {
                  id: "answer",
                  keys: ['left', 'right'],
                  correct: this.trial.centerArrow === "left" ? 'left' : 'right',
                  timeout: 1500
                }
              }
            }
          },
          Feedback: function() {
            var resp;
            resp = this.response[this.response.length - 1];
            console.log("feedback resp", this.response);
            return {
              Blank: {
                fill: resp.accuracy ? "green" : "red",
                opacity: .1
              },
              Next: {
                Timeout: {
                  duration: 200
                }
              }
            };
          }
        };
      },
      Coda: {
        Events: {
          1: {
            Action: {
              execute: function(context) {
                var dat, logdat, obj;
                dat = context.userData({
                  type: "response",
                  name: "KeyPress"
                }).get();
                console.log("dat:", dat);
                logdat = (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = dat.length; _i < _len; _i++) {
                    obj = dat[_i];
                    _results.push({
                      BlockNumber: obj.blockNumber,
                      RT: obj.RT,
                      TrialNumber: obj.trialNumber,
                      KeyChar: obj.keyChar,
                      NonResponse: obj.nonResponse,
                      Correct: obj.accuracy,
                      CenterArrow: obj.trial.centerArrow,
                      Flanker: obj.trial.flanker,
                      FlankerArrow: obj.trial.flankerArrow,
                      Task: "Flanker"
                    });
                  }
                  return _results;
                })();
                return context.set("resultObject", logdat);
              }
            }
          },
          2: {
            Text: {
              position: "center",
              origin: "center",
              content: ["End of Flanker Task", "Press the Space Bar to Continue"],
              fontSize: 28
            },
            Next: {
              SpaceKey: {}
            }
          }
        }
      },
      Save: function() {
        return {
          Action: {
            execute: function(context) {
              var logdat;
              if (context.get("active_brain")) {
                logdat = context.get("resultObject");
                console.log("sending data", logdat);
                return $.ajax({
                  type: "POST",
                  url: "/results",
                  data: JSON.stringify(logdat),
                  contentType: "application/json"
                });
              }
            }
          },
          Next: {
            Timeout: {
              duration: 200
            }
          }
        };
      }
    },
    Flow: function(routines) {
      return {
        1: routines.Prelude,
        2: {
          BlockSequence: {
            trialList: trials,
            start: routines.Block.Start,
            trial: routines.Trial,
            end: routines.Block.End
          }
        },
        3: routines.Coda,
        4: routines.Save
      };
    }
  };

  factorSet = {
    flanker: {
      levels: ["congruent", "incongruent"]
    },
    centerArrow: {
      levels: ["left", "right"]
    }
  };

  fnode = Psy.FactorSetNode.build(factorSet);

  trials = fnode.trialList(3, 4);

  trials = trials.bind(function(record) {
    return {
      flankerArrow: Psy.match(record.flanker, {
        congruent: record.centerArrow,
        incongruent: function() {
          return Psy.match(record.centerArrow, {
            left: "right",
            right: "left"
          });
        }
      })
    };
  });

  trials.shuffle();

  this.ArrowFlanker.start = (function(_this) {
    return function(subjectNumber, sessionNumber) {
      var pres;
      _this.context = new Psy.createContext();
      _this.context.set("active_brain", true);
      pres = new Psy.Presentation(trials, window.ArrowFlanker.experiment, context);
      return pres.start();
    };
  })(this);

}).call(this);
