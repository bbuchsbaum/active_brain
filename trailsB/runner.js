// Generated by CoffeeScript 1.7.1
(function() {
  var factorSet, fnode, instructionsA, instructionsB, trials, _;

  _ = Psy._;

  this.TrailsB = {};

  instructionsA = "<p>\n<p>\n\n**STOP!!**\n\n**READ** the following Instructions **CAREFULLY**\n\nTrail Making Task, Part 1\n==========================\nIn this task you will make a \"trail\" connecting circles in a particular order.\n\nYou will see a number circles appear on the screen. Each circle will have a number (1,2,3 ...) inside.\n\nYour goal is to make a trail linking all the numbered circles in order.\n\nYou will first look for the circle with \"1\" inside, click it, and then find \"2\" and click that, and so on.\n\nTo make a path between two circles, simply click the next circle in the path.\n\nWhen you select the correct circle, it will turn yellow. When you complete the trail, the final circle will turn red.\n\nPress any key to continue\n-------------------------\n";

  instructionsB = "\n<p>\n<p>\n\n**STOP!!**\n\n**READ** the following Instructions **CAREFULLY**\n\nTrail Making Task, Part 2\n==========================\n\nIn this task you will make a \"trail\" connecting circles in a particular order.\n\nYou will see a number circles appear on the screen. Each circle will have a number (1,2,3 ...) or a letter inside.\n\n\nYour goal is to make a trail linking all the numbered circles and lettered circles alternating in order between numbers and letters.\n\nFor example: 1 -> A -> 2 -> B -> 3 -> C\n\nTo make a path between two circles, simply click the next circle in the path.\n\nWhen you select the correct circle, it will turn yellow. When you complete the trail, the final circle will turn red.\n\n\nPress any key to continue\n-------------------------\n";

  this.TrailsB.experiment = {
    Define: {
      active_brain: true,
      trail_type: "A",
      resultObject: []
    },
    Routines: {
      Prelude_A: {
        Events: {
          1: {
            Markdown: instructionsA,
            Next: {
              AnyKey: ""
            }
          }
        }
      },
      Prelude_B: {
        Events: {
          1: {
            Markdown: instructionsB,
            Next: {
              AnyKey: ""
            }
          }
        }
      },
      Block: {
        Start: function() {
          return {
            Text: {
              position: "center",
              origin: "center",
              content: ["Get Ready!", "Press any key to start"]
            },
            Next: {
              AnyKey: ""
            }
          };
        }
      },
      TrialA: function() {
        var context, trail_move;
        context = this.context;
        trail_move = function(ev) {
          var resp, resultObj;
          resp = {
            RT: ev.RT,
            timeElapsed: ev.timeElapsed,
            index: ev.index,
            Task: "TrailsB",
            trialNumber: context.get("State.trialNumber"),
            blockNumber: context.get("State.blockNumber"),
            node: ev.node_id
          };
          resultObj = context.get("resultObject");
          resultObj.push(resp);
          return console.log(resultObj);
        };
        return {
          Background: {
            Blank: {
              fill: "gray"
            },
            CanvasBorder: {
              stroke: "black"
            }
          },
          Events: {
            1: {
              FixationCross: {
                length: 100
              },
              Timeout: {
                duration: 500
              }
            },
            2: {
              TrailsA: {
                id: "trails_a",
                npoints: 24,
                react: trail_move
              },
              Next: {
                Receiver: {
                  signal: "trail_completed"
                }
              }
            }
          },
          Feedback: function() {
            return {
              Text: {
                content: "Nice Job! Press Any Key to Continue.",
                position: "center",
                origin: "center"
              },
              Next: {
                AnyKey: ""
              }
            };
          }
        };
      },
      TrialB: function() {
        var context, trail_move;
        context = this.context;
        trail_move = function(ev) {
          var resp, resultObj;
          resp = {
            RT: ev.RT,
            timeElapsed: ev.timeElapsed,
            index: ev.index,
            Task: "TrailsB",
            trialNumber: context.get("State.trialNumber"),
            blockNumber: context.get("State.blockNumber"),
            node: ev.node_id
          };
          resultObj = context.get("resultObject");
          resultObj.push(resp);
          return console.log(resultObj);
        };
        return {
          Background: {
            Blank: {
              fill: "gray"
            },
            CanvasBorder: {
              stroke: "black"
            }
          },
          Events: {
            1: {
              FixationCross: {
                length: 100
              },
              Timeout: {
                duration: 500
              }
            },
            2: {
              TrailsB: {
                id: "trails_b",
                npoints: 24,
                react: trail_move
              },
              Next: {
                Receiver: {
                  signal: "trail_completed"
                }
              }
            }
          },
          Feedback: function() {
            return {
              Text: {
                content: "Nice Job! Press Any Key to Continue.",
                position: "center",
                origin: "center"
              },
              Next: {
                AnyKey: ""
              }
            };
          }
        };
      },
      EndOfA: {
        Events: {
          1: {
            Action: {
              execute: function(context) {
                console.log("setting trial type to B!!!");
                context.set("trail_type", "B");
                return console.log(context.get("trail_type"));
              }
            }
          }
        }
      },
      Coda: {
        Events: {
          1: {
            Text: {
              position: "center",
              origin: "center",
              content: ["End of Trails Task", "Press any key to continue"],
              fontSize: 32
            },
            Next: {
              AnyKey: {}
            }
          }
        }
      },
      Save: {
        Action: {
          execute: function(context) {
            var logdat;
            if (context.get("active_brain")) {
              logdat = context.get("resultObject");
              console.log("saving", logdat);
              return $.ajax({
                type: "POST",
                url: "/results",
                data: JSON.stringify(logdat),
                contentType: "application/json"
              });
            }
          }
        }
      }
    },
    Flow: function(routines) {
      return {
        1: routines.Prelude_A,
        2: {
          BlockSequence: {
            trialList: trials,
            start: routines.Block.Start,
            trial: routines.TrialA,
            end: routines.EndOfA
          }
        },
        3: routines.Prelude_B,
        4: {
          BlockSequence: {
            trialList: trials,
            start: routines.Block.Start,
            trial: routines.TrialB
          }
        },
        5: routines.Coda,
        6: routines.Save
      };
    }
  };

  factorSet = {
    trialnum: [1]
  };

  fnode = Psy.FactorSetNode.build(factorSet);

  trials = fnode.trialList(1, 1);

  this.TrailsB.start = (function(_this) {
    return function(subjectNumber, sessionNumber) {
      var context;
      context = new Psy.createContext();
      _this.pres = new Psy.Presentation(trials, _this.TrailsB.experiment, context);
      return _this.pres.start();
    };
  })(this);

}).call(this);
